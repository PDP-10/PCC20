;
;	C20PIP - TOPS-20 implementation of pipes using shared files
;
; The technique is to use a circular buffer within a shared file.  The
; first few words of the file are set aside for interlocking purposes,
; with the reader and writer (there must be only one of each) each
; mapping a single page at a time.

TITLE C20PIP
.INSRT PS:<C>CINSRT
.INSRT PS:<C>MINSRT

;; OFFSETS INTO DATA STRUCTURE

O.JFN==	0		;; JFN OF FILE
O.HDR==	1		;; POINTER TO HEADER PAGE
O.BUF==	2		;; POINTER TO BUFFER PAGE
O.WRT==	3		;; FLAG INDICATING DIRECTION
O.PTR==	4		;; POSITION
O.SIZ==	5		;; TOTAL SIZE

;; OFFSETS INTO HEADER PAGE

P.SIZE==  0		;; TOTAL SIZE OF THE FILE (ALWAYS EVEN PAGES)
P.FREE==  1		;; NUMBER OF FREE SLOTS (FOR WRITER)
P.USED==  2		;; NUMBER OF WORDS AVAIL TO READER
P.FLGS==  3		;; FLAGS
 P%WCLS==  1		;; WRITER HAS CLOSED
 P%RCLS==  2		;; READER HAS CLOSED
P.STRT==  4		;; FIRST USED WORD

;;	MKPIPE () => RETURN ADDRESS OF NEW STRUCTURE

CENTRY	MKPIPE,[],[Q]
	CALL	SALLOC,[[[O.SIZ]]]
	MOVEM	A, Q
	SETOM	O.JFN(A)
	CALL	PGJGET,[[[1]]]
	JUMPE	A, MK$BD1
	MOVE	B, Q
	MOVEM	A, O.HDR(B)
	CALL	PGJGET,[[[1]]]
	JUMPE	A, MK$BD2
	MOVE	B, Q
	MOVEM	A, O.BUF(B)
	MOVE	A, B
	RETURN
MK$BD2:	MOVE	B, Q
	MOVE	B, O.HDR(B)
	CALL	PGJRET,[B]
MK$BD1:	CALL	SFREE,[Q]
	MOVNI	A, 1
	RETURN

;;	SPIPE (PIPE, JFN, WRITING, SIZE)
;;		SETUP GIVEN PIPE TO USE STATED JFN AND DIRECTION
;;		SIZE IS SIZE OF PIPE IF WRITING, IGNORED IF READING

CENTRY	SPIPE,[PIPE,JFN,WRITING,SIZE]
	MOVE	A, PIPE
	SKIPL	O.JFN(A)	; SHOULD BE IN NEWLY ALLOCATED STATE
	 JRST	S$BAD
	MOVE	B, JFN
	MOVEM	B, O.JFN(A)
	SKIPE	WRITING
	 JRST	SWRITE
	SETZM	O.WRT(A)
SRTRY:	HRLZ	A, JFN
	FFUFP			; WAIT UNTIL PAGE 0 EXISTS
	 CAIA
	  JRST	SPMAP
	MOVEI	A, 100.		; WAIT FOR WRITER
	DISMS
	JRST	SRTRY

SPMAP:	HRLZ	A, JFN		; MAP IN FIRST PAGE
	MOVE	B, PIPE
	MOVE	B, O.HDR(B)
	LSH	B, -9.
	HRLI	B, .FHSLF
	MOVSI	C, (PM%RD\PM%WR)	; READ/WRITE ACCESS
	PMAP
	 ERJMP	S$BAD
	MOVE	B, PIPE
	MOVE	B, O.BUF(B)
	LSH	B, -9.
	HRLI	B, .FHSLF
	PMAP			; MAP TO BUFFER SLOT, TOO
	 ERJMP	S$BAD
	MOVE	A, PIPE
	MOVEI	B, P.STRT
	MOVEM	B, O.PTR(A)
	MOVEI	A, 1
	RETURN

SWRITE:	SETOM	O.WRT(A)
	MOVE	B, O.HDR(A)
	MOVE	C, SIZE
	ADDI	C, 777		; ROUND UP
	TRZ	C, 777
	MOVEM	C, P.SIZE(B)	; INIT HEADER
	SUBI	C, P.STRT
	MOVEM	C, P.FREE(B)
	SETZM	P.USED(B)
	SETZM	P.FLGS(B)
	MOVEI	A, (B)		; MAP THE PAGE OUT
	LSH	A, -9.
	HRLI	A, .FHSLF
	HRLZ	B, JFN
	MOVSI	C, (PM%RD\PM%WR)
	PMAP
	 ERJMP	S$BAD
	JRST	SPMAP

S$BAD:	MOVEI	A, 0
	RETURN

;;	RDPIPE (PIPE, BP, MAX)
;;		READS UP TO MAX UNITS INTO GIVEN BYTE POINTER
;;		RETURNS NUMBER READ; MUST BE > 0 UNLESS EOF

CENTRY	RDPIPE,[PIPE,BP,MAX]
	MOVE	A, PIPE
	SKIPN	O.WRT(A)
	 SKIPG	MAX
	  JRST	RD$BAD
	MOVN	C, O.PTR(A)	; HOW MUCH LEFT IN CURRENT PAGE ?
	ANDI	C, 777
	JUMPN	C, RDSOME
	MOVE	B, O.HDR(A)	; GET NEXT PAGE
	MOVE	C, O.PTR(A)
	CAMGE	C, P.SIZE(B)	; WRAP AROUND ?
	 JRST	RNWRAP
	MOVEI	C, P.STRT	; YES
	MOVEM	C, O.PTR(A)
RNWRAP:	LSH	C, -9.
	MOVE	B, O.BUF(A)
	LSH	B, -9.
	HRLI	B, .FHSLF
	HRL	A, O.JFN(A)
	HRRI	A, (C)
	MOVSI	C, (PM%RD\PM%WR)
	PMAP
	 ERJMP	RD$BAD
	MOVE	A, PIPE
	MOVE	B, O.PTR(A)
	ANDI	B, 777
	MOVEI	C, 1000
	SUBI	C, (B)
RDSOME:	CAMLE	C, MAX		; MORE THAN REQUESTED ?
	 MOVE	C, MAX
	MOVE	B, O.HDR(A)	; SEE HOW MUCH AVAILABLE
RDWAIT:	SKIPE	D, P.USED(B)
	 JRST	RDCONT
	MOVEI	A, P%WCLS	; WRITER DONE ?
	TDNE	A, P.FLGS(B)
	 JRST	RDEOF		; YEP ...
	MOVEI	A, 100.		; WAIT A LITTLE
	DISMS
	MOVE	A, PIPE
	JRST	RDWAIT

RDCONT:	CAMLE	C, D		; MIN AGAIN
	 MOVE	C, D
	MOVE	D, O.PTR(A)	; BLT DATA
	ANDI	D, 777
	ADD	D, O.BUF(A)
	HRLI	D, (D)
	HRR	D, BP		; GET DEST
	ADD	C, BP
	BLT	D, -1(C)
	SUB	C, BP
	MOVN	D, C
	ADDM	D, P.USED(B)	; DECREMENT AMOUNT USED
	ADDM	C, P.FREE(B)	; INCREMENT AMOUNT FREE
	ADDM	C, O.PTR(A)	; BUMP POINTER
	MOVEI	A, (C)		; RETURN AMOUNT TRANSFERRED
	RETURN

RDEOF:	TDZA	A, A		; GOT NONE
RD$BAD:	 MOVNI	A, 1
	RETURN

;;	WRPIPE (PIPE, BP, AMT)
;;		WRITES GIVEN AMT TO GIVEN PIPE FROM BYTE POINTER BP

CENTRY	WRPIPE,[PIPE,BP,AMT]
WRLOOP:	MOVE	A, PIPE
	SKIPE	O.WRT(A)
	 SKIPG	AMT
	  JRST	WR$BAD
	MOVN	C, O.PTR(A)	; HOW MUCH LEFT IN CURRENT PAGE ?
	ANDI	C, 777
	JUMPN	C, WRSOME
	MOVE	B, O.HDR(A)	; GET NEXT PAGE
	MOVE	C, O.PTR(A)
	CAMGE	C, P.SIZE(B)	; WRAP AROUND ?
	 JRST	WNWRAP
	MOVEI	C, P.STRT	; YES
	MOVEM	C, O.PTR(A)
WNWRAP:	LSH	C, -9.
	MOVE	B, O.BUF(A)
	LSH	B, -9.
	HRLI	B, .FHSLF
	HRL	A, O.JFN(A)
	HRRI	A, (C)
	MOVSI	C, (PM%RD\PM%WR)
	PMAP
	 ERJMP	WR$BAD
	MOVE	A, PIPE
	MOVE	B, O.PTR(A)
	ANDI	B, 777
	MOVEI	C, 1000
	SUBI	C, (B)
WRSOME:	CAMLE	C, AMT		; MORE THAN REQUESTED ?
	 MOVE	C, AMT
	MOVE	B, O.HDR(A)	; SEE HOW MUCH AVAILABLE
WRWAIT:	SKIPE	D, P.FREE(B)
	 JRST	WRCONT
	MOVEI	A, P%RCLS	; READER DONE ?
	TDNE	A, P.FLGS(B)
	 JRST	WREOF		; YEP ...
	MOVEI	A, 100.		; WAIT A LITTLE
	DISMS
	MOVE	A, PIPE
	JRST	WRWAIT

WRCONT:	CAMLE	C, D		; MIN AGAIN
	 MOVE	C, D
	MOVE	D, O.PTR(A)	; BLT DATA
	ANDI	D, 777
	ADD	D, O.BUF(A)
	HRL	D, BP
	MOVEI	A, (D)
	ADDI	A, (C)
	BLT	D, -1(A)
	MOVE	A, PIPE
	MOVN	D, C
	ADDM	D, P.FREE(B)	; DECREMENT AMOUNT FREE
	ADDM	C, P.USED(B)	; INCREMENT AMOUNT USED
	ADDM	C, O.PTR(A)	; BUMP POINTER
	ADDM	C, BP		; UPDATE COUNT AND BUFFER POINTER
	ADDB	D, AMT
	JUMPN	D, WRLOOP	; LOOP FOR MORE ?
	MOVEI	A, 1		; RETURN OK
	RETURN

WREOF:	TDZA	A, A		; GOT NONE
WR$BAD:	 MOVNI	A, 1
	RETURN

;;	CLPIPE (PIPE)
;;		CLOSES THE INDICATED PIPE

CENTRY	CLPIPE,[PIPE]
	MOVE	A, PIPE
	MOVEI	C, P%RCLS
	SKIPE	O.WRT(A)
	 MOVEI	C, P%WCLS
	MOVE	B, O.HDR(A)
	IORB	C, P.FLGS(B)
	TRC	C, P%RCLS\P%WCLS
	TRNN	C, P%RCLS\P%WCLS	; ARE WE SECOND TO CLOSE ?
	 JRST	CLKILL
	PUSH	P, PIPE
	PUSHJ	P, CUNMAP	; NO, UNMAP AND CLOSE
	POP	P, A
	MOVE	A, O.JFN(A)
	CLOSF
	 JRST	CL$BAD
CLCLR:	MOVE	A, PIPE
	MOVE	A, O.HDR(A)
	CALL	PGJRET,[A]
	MOVE	A, PIPE
	MOVE	A, O.BUF(A)
	CALL	PGJRET,[A]
	CALL	SFREE,[PIPE]
	MOVEI	A, 1
	RETURN

CLKILL:	PUSH	P, PIPE
	PUSHJ	P, CUNMAP	; UNMAP PAGES
	POP	P, A
	MOVE	A, O.JFN(A)
	HRLI	A, (CO%NRJ)	; DON'T RELEASE JFN
	CLOSF
	 JRST	CL$BAD
	HRLI	A, (DF%EXP)
	DELF			; DELETE AND EXPUNGE FILE
	 JRST	CL$BAD
	JRST	CLCLR

CUNMAP:	MOVNI	A, 1		; UNMAP PAGES FROM FORK
	MOVE	B, -1(P)	; GET PIPE POINTER
	MOVE	B, O.HDR(B)
	LSH	B, -9.
	HRLI	B, .FHSLF
	MOVEI	C, 0
	PMAP
	 ERJMP	CL$BD1
	MOVE	B, -1(P)
	MOVE	B, O.BUF(B)
	LSH	B, -9.
	HRLI	B, .FHSLF
	PMAP
	 ERJMP	CL$BD1
	POPJ	P,
CL$BD1:	POP	P, A		; FLUSH INNER RETURN ADDRESS
	POP	P, A		; AND ARGUMENT
CL$BAD:	MOVEI	A, 0
	RETURN

END
